Todo:
-----

- Create "object" class containing the file's definitions
	- make it (de)serializable?
- bulk out the standard library
- if we assign from a function result, pass the assignment target into the function link routine.
	- this way we can write straight to the assignment target
	- perhaps save this for after everything's working?
	- still probably better for function return location to be decided by caller, more convenient that way
- Use object destructors to give debug information as the stack is unwound: "inside while, inside function main" etc.
	- "defuse" them if the function completes successfully, otherwise they'll print an error message when destroyed.
- line numbers for syntax errors
- stack unwinding information for syntax errors ("in function main" etc.)
- have a better way of handling builtins! (some sort of map to function pointers?)
- Arrays
	- act as const pointers, but vardict allocates the correct amount of storage at the required location.
- Make code generator its own separate class, friend of linker.
- Make the compiler usable as a standalone executable.
- compile-to-RAM option
- export definitions and offsets of globals for RAM programs to use ROM routines.
- headers/preprocessor
- sort out temp collisions between ifs and logical functions
	- leave the temps allocated, so the ifs/whiles etc. don't clobber them
	- keep a list of the allocated temps
	- have a cleanuptemps() function that removes all of the allocated temps from the vardict.
- also have to do this for macros!
	- have a "clobbers" list?
	- or do the same thing, have a cleanuptemps() that executes when the macro's finished executing.
	- OR have a return value location for each logical operation?
		- Would probably be easier.
		- Would have to check a stack to see which functions we're currently inside, to avoid collisions.
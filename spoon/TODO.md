Todo:
-----

- bulk out the standard library
- if we assign from a function result, pass the assignment target into the function link routine.
	- this way we can write straight to the assignment target
	- perhaps save this for after everything's working?
	- still probably better for function return location to be decided by caller, more convenient that way
- Use object destructors to give debug information as the stack is unwound: "inside while, inside function main" etc.
	- "defuse" them if the function completes successfully, otherwise they'll print an error message when destroyed.
- line numbers for syntax errors
- stack unwinding information for syntax errors ("in function main" etc.)
- have a better way of handling builtins! (some sort of map to function pointers?)
- Arrays
	- act as const pointers, but vardict allocates the correct amount of storage at the required location.
	- have a varname struct instead of std::string in vardecs, which has an optional array length field
		- (like C modifiers)
	- at compile time, check that all arrays are of type int (or put in the semantics for other arrays)
	- give vardict::addvar an optional count parameter (default 1) which is multiplied into the type size before allocation.
		- also need to make a note of count for deallocation.
- Make code generator its own separate class, friend of linker.
- Make the compiler usable as a standalone executable.
- compile-to-RAM option
- export definitions and offsets of globals for RAM programs to use ROM routines.
- headers/preprocessor
- sort out temp collisions between ifs and logical functions
- also have to do this for macros!
	- have a "clobbers" list?
	- or do the same thing, have a cleanuptemps() that executes when the macro's finished executing.
	- OR have a return value location for each logical operation?
		- Would probably be easier.
		- Would have to check a stack to see which functions we're currently inside, to avoid collisions.
- strings!
- make vardict allocate from end of RAM, not start
	- otherwise we can't load programs into the start of RAM!
- make function definitions use vardeclaration::varpair instead of name and type. (lets us reuse getvarname_and_type() for array types)
- array indexing and lvalues, but for constant addresses only.